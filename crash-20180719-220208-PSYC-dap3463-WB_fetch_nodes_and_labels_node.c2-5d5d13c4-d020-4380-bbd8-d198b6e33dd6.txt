Node: Meta_wf_002.wb_functional_connectometry_002.WB_fetch_nodes_and_labels_node
Working directory: /var/folders/dk/9n8ng3n93q95kvx0zppcdtlh0000gp/T/tmp29a4zt4h/Meta_wf_002/wb_functional_connectometry_002/_atlas_select_None_parlistfile_None/WB_fetch_nodes_and_labels_node

Node inputs:

atlas_select = None
func_file = /Users/PSYC-dap3463/Downloads/002/002.nii.gz
function_str = def WB_fetch_nodes_and_labels(atlas_select, parlistfile, ref_txt, parc, func_file, use_AAL_naming):
    from pynets import utils, nodemaker
    import pandas as pd
    import os
    from pathlib import Path

    base_path = utils.get_file()

    # Test if atlas_select is a nilearn atlas. If so, fetch coords, labels, and/or networks.
    nilearn_parc_atlases = ['atlas_aal', 'atlas_craddock_2012', 'atlas_destrieux_2009']
    nilearn_coord_atlases = ['harvard_oxford', 'msdl', 'coords_power_2011', 'smith_2009', 'basc_multiscale_2015', 'allen_2011', 'coords_dosenbach_2010']
    if parlistfile is None and parc is False and atlas_select in nilearn_parc_atlases:
        [label_names, _, parlistfile] = utils.nilearn_atlas_helper(atlas_select)
        parcel_list = None
        par_max = None
        networks_list = None
    elif parlistfile is None and parc is False and atlas_select in nilearn_coord_atlases:
        print('Fetching coordinates and labels from nilearn coordinate-based atlases')
        # Fetch nilearn atlas coords
        [coords, _, networks_list, label_names] = nodemaker.fetch_nilearn_atlas_coords(atlas_select)
        parcel_list = None
        par_max = None
        networks_list = None
    else:
        try:
            # Fetch user-specified atlas coords
            [coords, atlas_select, par_max, parcel_list] = nodemaker.get_names_and_coords_of_parcels(parlistfile)
            # Describe user atlas coords
            print("%s%s%s%s" % ('\n', atlas_select, ' comes with {0} '.format(par_max), 'parcels\n'))
        except ValueError:
            print('\n\nError: Either you have specified the name of a nilearn atlas that does not exist or you have not supplied a 3d atlas parcellation image!\n\n')
            parcel_list = None
            par_max = None
        label_names = None
        networks_list = None

    # Labels prep
    if label_names:
        pass
    else:
        if ref_txt is not None and os.path.exists(ref_txt):
            dict_df = pd.read_csv(ref_txt, sep=" ", header=None, names=["Index", "Region"])
            label_names = dict_df['Region'].tolist()
        else:
            try:
                ref_txt = "%s%s%s%s" % (str(Path(base_path).parent), '/labelcharts/', atlas_select, '.txt')
                if os.path.exists(ref_txt):
                    try:
                        dict_df = pd.read_csv(ref_txt, sep="\t", header=None, names=["Index", "Region"])
                        label_names = dict_df['Region'].tolist()
                        #print(label_names)
                    except RuntimeError:
                        print("ERROR: label names from label reference file failed to populate or are invalid")
                else:
                    raise FileNotFoundError("ERROR: label reference file not found")
            except:
                if use_AAL_naming is True:
                    try:
                        label_names = nodemaker.AAL_naming(coords)
                        #print(label_names)
                    except:
                        print('AAL reference labeling failed!')
                        label_names = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()
                else:
                    print('Using generic labeled numbering...')
                    label_names = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()

    print(label_names)
    atlas_name = atlas_select
    dir_path = utils.do_dir_path(atlas_select, func_file)

    return label_names, coords, atlas_name, networks_list, parcel_list, par_max, parlistfile, dir_path

mask = <undefined>
parc = False
parlistfile = None
ref_txt = None
use_AAL_naming = False

Traceback (most recent call last):
  File "/usr/local/lib/python3.6/site-packages/nipype/pipeline/plugins/multiproc.py", line 69, in run_node
    result['result'] = node.run(updatehash=updatehash)
  File "/usr/local/lib/python3.6/site-packages/nipype/pipeline/engine/nodes.py", line 480, in run
    result = self._run_interface(execute=True)
  File "/usr/local/lib/python3.6/site-packages/nipype/pipeline/engine/nodes.py", line 564, in _run_interface
    return self._run_command(execute)
  File "/usr/local/lib/python3.6/site-packages/nipype/pipeline/engine/nodes.py", line 644, in _run_command
    result = self._interface.run(cwd=outdir)
  File "/usr/local/lib/python3.6/site-packages/nipype/interfaces/base/core.py", line 521, in run
    runtime = self._run_interface(runtime)
  File "/usr/local/lib/python3.6/site-packages/nipype/interfaces/utility/wrappers.py", line 144, in _run_interface
    out = function_handle(**args)
  File "<string>", line 27, in WB_fetch_nodes_and_labels
  File "/usr/local/lib/python3.6/site-packages/pynets-0.6.25-py3.6.egg/pynets/nodemaker.py", line 317, in get_names_and_coords_of_parcels
    atlas_select = parlistfile.split('/')[-1].split('.')[0]
AttributeError: 'NoneType' object has no attribute 'split'
